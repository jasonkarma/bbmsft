# BMSwift Project Guidelines

## 1. Architecture & Frameworks

### 1.1 Service Architecture
   - Define service protocols per feature
   - Implement in separate files
   - Support dependency injection
   - Example:
     ```swift
     protocol AuthService {
         func login(email: String, password: String) async throws -> LoginResponse
     }
     
     class AuthServiceImpl: AuthService {
         private let client: APIClient
     }
     ```

### 1.2 SwiftUI Guidelines
1. Primary UI Framework
   - Use SwiftUI for primary UI development
   - Use UIKit components only when SwiftUI alternatives don't exist
   - All UIKit integrations must use UIViewRepresentable

2. View Structure
   - Keep views small and focused (max 150 lines)
   - Extract reusable components to separate files
   - Use ViewBuilder for complex view logic
   - Follow composition over inheritance

3. Environment & State Management
   - Use @Environment only for SwiftUI system values
   - Avoid naming conflicts with environment keys
   ```swift
   // Good
   @Environment(\.dismiss) private var dismissAction
   @Environment(\.presentationMode) private var presentation
   
   // Bad - Avoid using same name as environment key
   @Environment(\.dismiss) private var dismiss  // Don't do this

4. View Presentation & Dismissal
• Use @Binding for sheet and full-
screen presentations

// In the presenting view
@State private var isShowingRegister = false

// Show the sheet
.sheet(isPresented: $isShowingRegister) {
    RegisterView(isPresented: $isShowingRegister)
}

// In the presented view
struct RegisterView: View {
    @Binding var isPresented: Bool
    
    init(isPresented: Binding<Bool>) {
        self._isPresented = isPresented
    }
}

1.3 Project Organization
• Features-based directory structure
• Base networking in Services/Network
• Feature-specific code in
Features/{Feature) Example structure:

Features/
  Auth/
    Models/
    Services/
    ViewModels/
Services/
  Network/
    Base/

2. Networking Guidelines
2.1 Core Types

public enum LogLevel {
    case debug
    case info
    case warning
    case error
}

public enum ViewState {
    case idle
    case loading
    case success(Any)
    case error(Error)
}

public enum APIError: LocalizedError, Identifiable {
    case networkError(Error)
    case serverError(String)
    case invalidResponse
    case decodingError(Error)
    case notImplemented
    
    public var id: String { localizedDescription }
    public var errorDescription: String? {
        switch self {
        case .networkError(let error): return "Network error: \(error.localizedDescription)"
        case .serverError(let message): return message
        case .invalidResponse: return "Invalid server response"
        case .decodingError(let error): return "Data error: \(error.localizedDescription)"
        case .notImplemented: return "Method not implemented"
        }
    }
}

2.2 API Structure
• Use protocol-based API endpoints
• Organize endpoints under feature
namespaces
• Each endpoint is a separate type
Example:

protocol APIEndpoint {
    associatedtype Request: Codable
    associatedtype Response: Codable
}

enum API.Auth {
    struct LoginEndpoint: APIEndpoint {
        typealias Request = LoginRequest
        typealias Response = LoginResponse
    }
}
2.3 Request/Response Models
Organize models under feature
namespaces
All models must conform to Codable
Use explicit CodingKeys Example:

enum API.Auth {
    struct LoginRequest: Codable {
        let email: String
        let password: String
        
        enum CodingKeys: String, CodingKey {
            case email
            case password
        }
    }
}

2.4 Environment Configuration

public enum Environment {
    case development
    case production
    
    var apiBaseURL: URL {
        switch self {
        case .development:
            return URL(string: "https://dev-api.blackboard.com")!
        case .production:
            return URL(string: "https://api.blackboard.com")!
        }
    }
    
    var logLevel: LogLevel {
        switch self {
        case .development: return .debug
        case .production: return .error
        }
    }
}

3. Application Features
3.1 Localization
1. Language Support
• Primary language: Traditional
Chinese (zh-Hant)
• All user-facing strings must be
localized
Use string catalogs for localization
Example:
Text("login.button.title".localized)

2. Date & Number Formatting
• Use locale-aware formatters
• Support Taiwan calendar and time
zones

3.2 ViewModels
1. Structure and Best Practices
• Use protocol-based services with
dependency injection
• Use @Published for observable state
• Keep business logic out of views
• Handle all error cases
Show loading states
• Use async/await for asynchronous
operations Example:

@MainActor
class LoginViewModel: ObservableObject {
    @Published private(set) var state: ViewState = .idle
    @Published var error: APIError?
    
    private let authService: AuthService
    
    init(authService: AuthService = AuthServiceImpl()) {
        self.authService = authService
    }
    
    func login(email: String, password: String) async {
        state = .loading
        do {
            let response = try await authService.login(email: email, password: password)
            state = .success(response)
        } catch let error as APIError {
            self.error = error
            state = .error(error)
        } catch {
            let apiError = APIError.networkError(error)
            self.error = apiError
            state = .error(apiError)
        }
    }
}

4. Testing
4.1 Unit Tests
• Required for all ViewModels
• Required for API services
Use protocol-based mocks
• Test all error scenarios Example:

class MockAuthService: AuthService {
    var loginResult: Result<LoginResponse, Error>?
    
    func login(email: String, password: String) async throws -> LoginResponse {
        guard let result = loginResult else {
            throw APIError.notImplemented
        }
        return try result.get()
    }
}

4.2 Ul Tests
• Basic flow testing
Accessibility testing
• Different device sizes
5. Documentation
5.1 File Headers

/// BMSwift - Login View
/// Handles user authentication UI
///
/// Dependencies:
/// - LoginViewModel: Handles login logic
/// - APIService: Network operations

5.2 Public APis
• Document all public methods and
properties
• Include parameter descriptions
• Document possible errors
• Add usage examples
6. Asset Management
6.1 Image Assets
• Use asset catalogs
• Support dark mode
• Include @2x and @3x sizes
• Use PDF for icons when possible
6.2 Colors
• Define in AppColors
Support dark mode
• Use semantic naming
7. Security
7.1 Data Storage
• Never store passwords
• Use Keychain for sensitive data
• Clear sensitive data on logout
7.2 Network Security
• Use HTTPS only
• Certificate pinning
• Validate all responses

8. Dependency Injection
8.1 Service Registration
Use protocols for service definitions
Provide default implementations
Support testing with mock services
Example:

protocol ServiceProvider {
    var authService: AuthService { get }
    var encyclopediaService: EncyclopediaService { get }
}

class DefaultServiceProvider: ServiceProvider {
    let authService: AuthService = AuthServiceImpl()
    let encyclopediaService: EncyclopediaService = EncyclopediaServiceImpl()
}

9. Concurrency
9.1 Async/Await Usage
• Use async/await for all asynchronous
operations
• Mark Ul updates with @MainActor
• Use Task for background operations
Handle cancellation appropriately
Example:

@MainActor
class ViewModel: ObservableObject {
    private var task: Task<Void, Never>?
    
    func loadData() {
        task?.cancel()
        task = Task {
            // Async work here
        }
    }
    
    deinit {
        task?.cancel()
    }
}