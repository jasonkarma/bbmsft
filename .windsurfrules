# BMSwift Project Guidelines

## 1. Architecture & Frameworks

### SwiftUI Guidelines
1. Primary UI Framework
   - Use SwiftUI for primary UI development
   - Use UIKit components only when SwiftUI alternatives don't exist
   - All UIKit integrations must use UIViewRepresentable

2. View Structure
   - Keep views small and focused (max 150 lines)
   - Extract reusable components to separate files
   - Use ViewBuilder for complex view logic
   - Follow composition over inheritance

3. Environment & State Management
   - Use @Environment only for SwiftUI system values
   - Avoid naming conflicts with environment keys
   ```swift
   // Good
   @Environment(\.dismiss) private var dismissAction
   @Environment(\.presentationMode) private var presentation
   
   // Bad - Avoid using same name as environment key
   @Environment(\.dismiss) private var dismiss  // Don't do this
    Never use custom types with @Environment

4. View Presentation & Dismissal
   - Use @Binding for sheet and full-screen presentations
   ```swift
   // In the presenting view
   @State private var isShowingRegister = false
   
   // Show the sheet
   .sheet(isPresented: $isShowingRegister) {
       RegisterView(isPresented: $isShowingRegister)
   }
   
   // In the presented view
   struct RegisterView: View {
       @Binding var isPresented: Bool
       
       init(isPresented: Binding<Bool>) {
           self._isPresented = isPresented
       }
       
       // Dismiss by setting binding to false
       isPresented = false
   }

Networking Guidelines
1.API Structure
All endpoints defined in APIService.swift using enums
enum APIEndpoint {
    static let baseURL = Environment.current.apiBaseURL
    case login
    case register
    
    var path: String {
        switch self {
        case .login: return "/api/login"
        case .register: return "/api/register"
        }
    }
}

2. Error Handling
public struct APIError: Error, Codable {
    public let error: [String]
    
    public var localizedDescription: String {
        error.joined(separator: "\n")
    }
}

3.Request/Response Models
All models must conform to Codable
Use explicit CodingKeys
Include documentation comments

/// Login request model
public struct LoginRequest: Codable {
    /// User email
    let email: String
    /// User password (never stored)
    let password: String
    /// Request source
    let from: String = "ios"
}

Environment Configuration
public enum Environment {
    case development
    case production
    
    static var current: Environment {
        #if DEBUG
        return .development
        #else
        return .production
        #endif
    }
    
    var apiBaseURL: String {
        switch self {
        case .development:
            return "https://dev-api.blackboard.com"
        case .production:
            return "https://api.blackboard.com"
        }
    }
}

2.Localization
    1.Language Support
        Primary language: Traditional Chinese (zh-Hant)
        All user-facing strings must be localized
        Use string catalogs for localization
            Text("login.button.title".localized)

    2.Date & Number Formatting
        Use locale-aware formatters
        Support Taiwan calendar and time zones

3.ViewModels
    1.Structure

    class LoginViewModel: ObservableObject {
    @Published private(set) var isLoading = false
    @Published var errorMessage: String?
    
    private let apiService = APIService.shared
    
    func login() async {
        do {
            isLoading = true
            let response = try await apiService.login(request)
            // Handle success
        } catch let error as APIError {
            errorMessage = error.localizedDescription
        } catch {
            errorMessage = "發生未知錯誤"
        }
        isLoading = false
    }
}

    2.Best Practices
        Use @Published for observable properties
        Keep business logic out of views
        Handle all error cases
        Show loading states
        Use async/await for asynchronous operations

4.Testing Requirements
    1. Unit Tests
      
        Required for all ViewModels
        Required for API services
        Mock all network calls
        Test error scenarios
    2.UI Tests
        Basic flow testing
        Accessibility testing
        Different device sizes

5. Documentation
    1.File Headers
        /// BMSwift - Login View
        /// Handles user authentication UI
        ///
        /// Dependencies:
        /// - LoginViewModel: Handles login logic
        /// - APIService: Network operations

    2.Public APIs
        Document all public methods and properties
        Include parameter descriptions
        Document possible errors
        Add usage examples

6. Asset Management
    1.Image Assets
        Use asset catalogs
        Support dark mode
        Include @2x and @3x sizes
        Use PDF for icons when possible
    2.Colors
        Define in AppColors
        Support dark mode
        Use semantic naming

7. Security
    1.Data Storage
        Never store passwords
        Use Keychain for sensitive data
        Clear sensitive data on logout
    2.Network Security
        Use HTTPS only
        Certificate pinning
        Validate all responses